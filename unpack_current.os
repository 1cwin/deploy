#Использовать logos
#Использовать gitsync

Перем Лог;
Перем dev_EPF, Кеш, КешНовый;
Перем МассивИзмененных;
Перем Sync, Runner;
Перем СтрокаПодключения, соотвСозданныхКаталогов;

procedure Инициализация()
 
    Лог = Логирование.ПолучитьЛог("vega.dev.newepf");
    Лог.УстановитьУровень(УровниЛога.Отладка);
    
    ВыводПоУмолчанию = Новый ВыводЛогаВКонсоль();
    Лог.ДобавитьСпособВывода(ВыводПоУмолчанию);
	
	SystemInfo = new SystemInfo;
	dev_EPF 			= SystemInfo.GetEnvironmentVariable("dev_EPF");
	dev_Server1C 		= SystemInfo.GetEnvironmentVariable("dev_Server1C");
	dev_Catalog 		= SystemInfo.GetEnvironmentVariable("dev_Catalog");
	dev_SourceCatalog 	= SystemInfo.GetEnvironmentVariable("dev_SourceCatalog");
	
	Лог.Отладка("dev_EPF="+dev_EPF);
	Лог.Отладка("dev_Server1C="+dev_Server1C);
	Лог.Отладка("dev_Catalog="+dev_Catalog);
	Лог.Отладка("dev_SourceCatalog="+dev_SourceCatalog);
	
	Если dev_Server1C = "" Тогда
		Лог.Ошибка("Сервер разработки не указан! заполните dev_Server1C");
		ЗавершитьРаботу(1);
	КонецЕсли;

	Если dev_Catalog = "" Тогда
		Лог.Ошибка("Каталог скриптов не указан! заполните dev_Catalog");
		ЗавершитьРаботу(1);
	КонецЕсли;

	Если dev_SourceCatalog = "" Тогда
		Лог.Ошибка("Каталог исходников не указан! заполните dev_SourceCatalog");
		ЗавершитьРаботу(1);
	КонецЕсли;

	ФайлМенеджерСинхронизации = Новый Файл(ОбъединитьПути(dev_Catalog, "lib", "МенеджерСинхронизации.os"));
	Если ФайлМенеджерСинхронизации.Существует() Тогда
		ПодключитьСценарий(ФайлМенеджерСинхронизации.ПолноеИмя, "ObjSync");
		Sync = Новый ObjSync();
		Sync.ТихийРежим = Истина;
	Иначе
		Лог.Ошибка("Не найден скрипт ""МенеджерСинхронизации.os"" ");
		ЗавершитьРаботу(1);
	КонецЕсли;
	
	ФайлRunner = Новый Файл(ОбъединитьПути(dev_Catalog, "lib", "Runner.os"));
	Если ФайлRunner.Существует() Тогда
		ПодключитьСценарий(ФайлRunner.ПолноеИмя, "ObjRunner");
		Runner = Новый ObjRunner();
	Иначе
		Runner = Неопределено;
		Лог.Ошибка("Не найден скрипт ""Runner.os"". Разборка EPF не подерживается!");
		ЗавершитьРаботу(1);
	КонецЕсли;
	
	ПроверитьИСоздатьGit_EPFDir();

	Кеш = Новый Соответствие;
	КешНовый = Новый Соответствие;
	МассивИзмененных = Новый Массив;
	
	Файл = Новый Файл(ОбъединитьПути(dev_EPF, ".cache"));
	Если Файл.Существует() Тогда
		ПрочитатьКешФайл();
		ОбработатьСтатусы();
	Иначе
		ОбработатьСтатусы();
		ЗаписатьКешФайл();
		ЗавершитьРаботу(1);
	КонецЕсли;
	
	Если МассивИзмененных.Количество()=0 Тогда
		Лог.Ошибка("Не найдено измененных обработок");
		ЗавершитьРаботу(1);
	КонецЕсли;
	
	соотвСозданныхКаталогов = Новый Соответствие;
	РВ = Новый РегулярноеВыражение("/");
	Для Каждого ПолноеИмя из МассивИзмененных Цикл
		Файл = Новый Файл(ОбъединитьПути(dev_EPF, ПолноеИмя));
		Если НЕ Файл.Существует() Тогда
			Продолжить;
		КонецЕсли;
		ИмяБазы = "";
		Поиск = РВ.Разделить(ПолноеИмя);
		Если Поиск.Количество()<2 Тогда
			Продолжить;
		ИначеЕсли Поиск.Количество()>1 Тогда
			ИмяБазы = Поиск.Получить(0);
		КонецЕсли;
		Если ИмяБазы = "" Тогда
			Лог.Ошибка("ИмяБазы не определено!");
			Продолжить;
		КонецЕсли;
		Лог.Отладка("ИмяБазы=" + ИмяБазы);
	
		КаталогИсходников = ОбъединитьПути(dev_SourceCatalog, ИмяБазы, Врег(СокрЛП(Сред(Файл.Расширение,2))));
		СтрокаПодключения = "/S" + dev_Server1C + "\" + ИмяБазы;
		Лог.Отладка("КаталогИсходников="+КаталогИсходников);
		Лог.Отладка("СтрокаПодключения="+СтрокаПодключения);

		ПроверитьИСоздатьКаталог(КаталогИсходников);
		
		Ошибка = Ложь;
		Попытка
			Runner.Декомпилировать(Файл.ПолноеИмя, КаталогИсходников,, СтрокаПодключения);
			ВыполнитьКоммит(КаталогИсходников, Файл.Имя, Файл.ПолучитьВремяИзменения());
		Исключение
			Ошибка = Истина;
		КонецПопытки;
		
		Если Ошибка Тогда
			ПредДата = Кеш.Получить(ПолноеИмя);
			Если ПредДата<>Неопределено Тогда КешНовый.Вставить(ПолноеИмя, ПредДата); КонецЕсли;	
		Иначе
			Лог.Отладка("Обработан файл : " + Файл.Имя);
		КонецЕсли;
		
	КонецЦикла;
	ЗаписатьКешФайл();

КонецПроцедуры

procedure ПроверитьИСоздатьКаталог(Знач Каталог)
	Если соотвСозданныхКаталогов.Получить(Каталог) = Неопределено Тогда
		ФайлКаталога = Новый Файл(Каталог);
		Если НЕ ФайлКаталога.Существует() Тогда
			СоздатьКаталог(Каталог);
			Лог.Отладка("Создан каталог = "+Каталог);
		КонецЕсли; 	
		соотвСозданныхКаталогов.Вставить(Каталог, Истина);
	КонецЕсли;
endprocedure

procedure ПроверитьИСоздатьGit_EPFDir()

	//	если нет файла .gitignore то перед инициализацией репозитория
	//	создаем его, чтобы после git init сразу получить командой git status все необходимые файлы
	
	Файл = Новый Файл(ОбъединитьПути(dev_EPF, ".gitignore"));
	Если НЕ Файл.Существует() Тогда
		Запись = Новый ЗаписьТекста(Файл.ПолноеИмя);
		Запись.ЗаписатьСтроку("*");	// запрещаем все
		Запись.ЗаписатьСтроку("!/*/*.e?f"); // кроме файлов обработок и отчетов в каталогах базы формата: ИмяБазы/Имяфайла.epf или erf
		Запись.ЗаписатьСтроку("!*/"); // разрешаем смотреть во вложенных каталогах
		Запись.ЗаписатьСтроку(".*/");// отключаем служебные каталоги начинающиеся с .
		Запись.Закрыть();
	КонецЕсли;
	
	Если Sync.ПроверитьНаличиеРепозитарияГит(dev_EPF) = Ложь Тогда
		Sync.ИнициализироватьРепозитарий(dev_EPF);
	КонецЕсли;
	
endprocedure

procedure ВыполнитьКоммит(Знач Каталог, Знач Коммент, Знач ДатаИзменения);
	Автор = "";
	Ошибка = Ложь;
	Попытка
		Sync.ВыполнитьКоммитГит(Каталог, Коммент, Автор, ДатаИзменения);
	Исключение
		Лог.Ошибка("Ошибка коммита " + Коммент);
		Ошибка = Истина;
	КонецПопытки;
endprocedure

procedure ОбработатьСтатусы()
	СформироватьНовыйФайлСтатус();
	ПолучитьОтличия();
КонецПроцедуры

procedure ПрочитатьКешФайл()
	ИмяФК = ОбъединитьПути(dev_EPF, ".cache");
	Чтение = Новый ЧтениеТекста(ИмяФК, КодировкаТекста.utf8);
	Стр = Чтение.ПрочитатьСтроку();
	Пока Стр <> Неопределено Цикл
		ВремяИзменения = Лев(Стр, 25);
		ПолныйПуть = Сред(Стр, 26);
		Кеш.Вставить(ПолныйПуть, ВремяИзменения);
		Стр = Чтение.ПрочитатьСтроку();
	КонецЦикла;
	Чтение.Закрыть();
КонецПроцедуры

procedure ЗаписатьКешФайл()
	ИмяФК = ОбъединитьПути(dev_EPF, ".cache");
	Запись = Новый ЗаписьТекста(ИмяФК);
	Для Каждого КлючЗначение Из КешНовый Цикл
		ВремяИзменения = Строка(КлючЗначение.Значение);
		Если ВремяИзменения="" Тогда Продолжить; КонецЕсли;
		Пока СтрДлина(ВремяИзменения)<25 Цикл ВремяИзменения=ВремяИзменения + " "; КонецЦикла;
		Запись.ЗаписатьСтроку(ВремяИзменения + КлючЗначение.Ключ);
	КонецЦикла;
	Запись.Закрыть();
КонецПроцедуры

procedure ПолучитьОтличия()
	Файл = Новый Файл(ОбъединитьПути(dev_EPF, ".status"));
	Если Файл.Существует() Тогда
		Чтение = Новый ЧтениеТекста(Файл.ПолноеИмя, КодировкаТекста.utf8);
		Стр = Чтение.ПрочитатьСтроку();
		Пока Стр <> Неопределено Цикл
			Расш = Нрег(Прав(Стр,4));
			Если Расш = ".epf" ИЛИ Расш = ".erf" Тогда
				ИмяФайла = СокрЛ(Стр);
				ПроверитьИзменения(ИмяФайла);
			КонецЕсли;
			Стр = Чтение.ПрочитатьСтроку();
		КонецЦикла;
		Чтение.Закрыть();
	КонецЕсли;
КонецПроцедуры

procedure ПроверитьИзменения(Знач ПолныйПуть)
	Файл = Новый Файл(ОбъединитьПути(dev_EPF, ПолныйПуть));
	НовоеВремя = "";
	Если Файл.Существует() Тогда
		ВремяИзменения = Кеш.Получить(ПолныйПуть);
		НовоеВремя = Строка(Файл.ПолучитьВремяИзменения());
		Если СокрЛП(ВремяИзменения) = "" Тогда
			МассивИзмененных.Добавить(ПолныйПуть);
			Лог.Отладка("Новый = "+ ПолныйПуть);
		ИначеЕсли СокрЛП(ВремяИзменения)<>СокрЛП(НовоеВремя) Тогда
			МассивИзмененных.Добавить(ПолныйПуть);
			Лог.Отладка("Изменен = "+ ПолныйПуть);
		КонецЕсли;
	КонецЕсли;
	КешНовый.Вставить(ПолныйПуть, НовоеВремя);
КонецПроцедуры

function СоздатьКомандныйФайл()
	Файл = Новый КомандныйФайл();
	Файл.Открыть(ОбъединитьПути(dev_EPF, "query.cmd"));
	Файл.Добавить("@echo off");
	Файл.Добавить("cd /d " + dev_EPF);
	Файл.Добавить("git status --untracked-files=all > .status");
	Файл.Добавить("exit /b %ERRORLEVEL%");
	Возврат Файл;
КонецФункции

function ВыполнитьКомандныйФайл(Знач ДескрипторКомандногоФайла)
	Возврат ДескрипторКомандногоФайла.Выполнить();
КонецФункции

procedure СформироватьНовыйФайлСтатус()
	кодВозврата = ВыполнитьКомандныйФайл(СоздатьКомандныйФайл());
	Если кодВозврата<>0 Тогда
		Лог.Ошибка("Не удалось записать .status");
		ЗавершитьРаботу(кодВозврата);
	КонецЕсли;
КонецПроцедуры



Инициализация();



